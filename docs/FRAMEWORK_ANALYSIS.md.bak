# GraphGenæ¡†æ¶è¯¦ç»†è§£æ

æœ¬æ–‡æ¡£åŸºäºä»£ç åº“å®ç°ï¼Œè¯¦ç»†è§£æGraphGenæ¡†æ¶çš„å››ä¸ªæ ¸å¿ƒæ­¥éª¤åŠå…¶æŠ€æœ¯å®ç°ã€‚

## ä¸€ã€GraphGenæ¡†æ¶æ¦‚è¿°

GraphGenæ˜¯ä¸€ä¸ª**çŸ¥è¯†å›¾è°±å¼•å¯¼çš„åˆæˆæ•°æ®ç”Ÿæˆæ¡†æ¶**ï¼Œä¸“ä¸ºè§£å†³å¤§è¯­è¨€æ¨¡å‹(LLMs)ç›‘ç£å¾®è°ƒ(SFT)ä¸­çš„é«˜è´¨é‡è®­ç»ƒæ•°æ®ç¨€ç¼ºé—®é¢˜è€Œè®¾è®¡ã€‚è¯¥æ¡†æ¶ç‰¹åˆ«é’ˆå¯¹**çŸ¥è¯†å¯†é›†å‹ä»»åŠ¡**ï¼Œé€šè¿‡ç»“æ„åŒ–çŸ¥è¯†æŒ‡å¯¼ï¼Œç³»ç»Ÿæ€§æé«˜åˆæˆæ•°æ®è´¨é‡ï¼Œé¿å…ä¼ ç»Ÿåˆæˆæ•°æ®æ–¹æ³•å¸¸è§çš„äº‹å®é”™è¯¯ã€çŸ¥è¯†è¦†ç›–ä¸è¶³å’ŒåŒè´¨åŒ–é—®é¢˜ã€‚

### æ¡†æ¶æ ¸å¿ƒç‰¹ç‚¹

- **é’ˆå¯¹ä¸‰ç§å…³é”®é—®ç­”(QA)åœºæ™¯ä¼˜åŒ–**ï¼šåŸå­QA(atomic QA)ã€èšåˆQA(aggregated QA)å’Œå¤šè·³QA(multi-hop QA)
- **é‡‡ç”¨é¢„æœŸæ ¡å‡†è¯¯å·®(ECE)è¯†åˆ«æ¨¡å‹çŸ¥è¯†ç›²ç‚¹**ï¼Œä¼˜å…ˆç”Ÿæˆé«˜ä»·å€¼ã€é•¿å°¾çŸ¥è¯†
- **é€šè¿‡å¤šè·³é‚»åŸŸé‡‡æ ·æ•è·å¤æ‚å…³ç³»ä¿¡æ¯**
- **ä½¿ç”¨é£æ ¼æ§åˆ¶ç”Ÿæˆæé«˜æ•°æ®å¤šæ ·æ€§**

### ä»£ç å®ç°ä½ç½®

æ ¸å¿ƒæ¡†æ¶å®ç°åœ¨ `graphgen/graphgen.py` ä¸­çš„ `GraphGen` ç±»ï¼Œä¸»è¦åŒ…å«ä»¥ä¸‹æ–¹æ³•ï¼š
- `insert()`: çŸ¥è¯†æ„å»º
- `quiz_and_judge()`: ç†è§£è¯„ä¼°
- `generate()`: QAç”Ÿæˆï¼ˆåŒ…å«å›¾ç»„ç»‡æ­¥éª¤ï¼‰

---

## äºŒã€GraphGenå››æ­¥å·¥ä½œæµç¨‹

### æ­¥éª¤1ï¼šçŸ¥è¯†æ„å»º(Knowledge Construction)

**ç›®æ ‡**ï¼šä»åŸå§‹æ–‡æœ¬æ„å»ºç»†ç²’åº¦çŸ¥è¯†å›¾è°±

**ä»£ç å®ç°ä½ç½®**ï¼š
- ä¸»å…¥å£ï¼š`graphgen/graphgen.py::GraphGen.insert()`
- æ–‡æœ¬çŸ¥è¯†å›¾è°±æ„å»ºï¼š`graphgen/operators/build_kg/build_text_kg.py`
- å¤šæ¨¡æ€çŸ¥è¯†å›¾è°±æ„å»ºï¼š`graphgen/operators/build_kg/build_mm_kg.py`
- çŸ¥è¯†æå–å™¨ï¼š`graphgen/models/kg_builder/light_rag_kg_builder.py`

**è¯¦ç»†è¿‡ç¨‹**ï¼š

#### 1. æ–‡æ¡£åˆ†å‰²

**å®ç°ä½ç½®**ï¼š`graphgen/operators/split/split_chunks.py`

- å°†åŸå§‹æ–‡æ¡£åˆ†å‰²æˆè¾ƒå°çš„ã€è¯­ä¹‰è¿è´¯çš„ç‰‡æ®µ
- ä½¿ç”¨ä¸Šä¸‹æ–‡æ„ŸçŸ¥åˆ†å—æŠ€æœ¯
- æ”¯æŒå¤šç§åˆ†å‰²ç­–ç•¥ï¼š
  - `RecursiveCharacterSplitter`: é€’å½’å­—ç¬¦åˆ†å‰²
  - `CharacterSplitter`: å­—ç¬¦åˆ†å‰²
  - `MarkdownSplitter`: Markdownåˆ†å‰²

**é…ç½®å‚æ•°**ï¼ˆè§ `graphgen/configs/*.yaml`ï¼‰ï¼š
```yaml
split:
  chunk_size: 1024      # åˆ†å—å¤§å°
  chunk_overlap: 100     # åˆ†å—é‡å 
```

#### 2. å®ä½“/å…³ç³»æå–

**å®ç°ä½ç½®**ï¼š
- æå–é€»è¾‘ï¼š`graphgen/models/kg_builder/light_rag_kg_builder.py::LightRAGKGBuilder.extract()`
- æç¤ºæ¨¡æ¿ï¼š`graphgen/templates/kg/kg_extraction.py`

**è¯¦ç»†æµç¨‹**ï¼š

1. **è¯­è¨€æ£€æµ‹**ï¼šä½¿ç”¨ `detect_main_language()` æ£€æµ‹æ–‡æ¡£è¯­è¨€ï¼ˆä¸­æ–‡/è‹±æ–‡ï¼‰

2. **LLMæå–**ï¼šä½¿ç”¨åˆæˆå™¨æ¨¡å‹(Msynthï¼Œé€šå¸¸ä¸ºèƒ½åŠ›æ›´å¼ºçš„LLMï¼Œå¦‚Qwen2.5-72B)ä»ç‰‡æ®µä¸­æå–å®ä½“å’Œå…³ç³»
   ```python
   # graphgen/models/kg_builder/light_rag_kg_builder.py:36-41
   hint_prompt = KG_EXTRACTION_PROMPT[language]["TEMPLATE"].format(
       **KG_EXTRACTION_PROMPT["FORMAT"], input_text=content
   )
   final_result = await self.llm_client.generate_answer(hint_prompt)
   ```

3. **å®ä½“ç±»å‹**ï¼šé¢„å®šä¹‰å®ä½“ç±»å‹åŒ…æ‹¬ï¼š
   - é€šç”¨ç±»åˆ«ï¼šæ—¥æœŸ(date)ã€ä½ç½®(location)ã€äº‹ä»¶(event)ã€äººç‰©(person)ã€ç»„ç»‡(organization)ç­‰
   - é¢†åŸŸç‰¹å®šç±»åˆ«ï¼šå¦‚åŒ»ç–—ä¸­çš„åŸºå› (gene)ã€å†œä¸šä¸­çš„ä½œç‰©å“ç§(work)ç­‰

4. **è§£æç»“æœ**ï¼šä»LLMå“åº”ä¸­è§£æå®ä½“å’Œå…³ç³»
   ```python
   # graphgen/models/kg_builder/light_rag_kg_builder.py:65-96
   records = split_string_by_multi_markers(final_result, ...)
   for record in records:
       entity = await handle_single_entity_extraction(attributes, chunk_id)
       relation = await handle_single_relationship_extraction(attributes, chunk_id)
   ```

#### 3. çŸ¥è¯†èšåˆ

**å®ç°ä½ç½®**ï¼š`graphgen/models/kg_builder/light_rag_kg_builder.py::merge_nodes()` å’Œ `merge_edges()`

- å½“åŒä¸€å®ä½“/å…³ç³»å‡ºç°åœ¨å¤šä¸ªç‰‡æ®µæ—¶ï¼Œè‡ªåŠ¨åˆå¹¶å…¶æè¿°
- è·¨ç‰‡æ®µå®ä½“å’Œå…³ç³»èšåˆæˆå®Œæ•´çŸ¥è¯†å›¾è°±G=(E, R)
- ä½¿ç”¨ `NetworkXStorage` å­˜å‚¨çŸ¥è¯†å›¾è°±

**ä¼˜åŠ¿**ï¼š
- ç»“åˆLLMså’ŒKGsï¼Œè§£å†³é•¿æ–‡æœ¬å¤„ç†ã€æ ¼å¼å™ªå£°å’ŒçŸ¥è¯†åˆ†æ•£åˆ†å¸ƒç­‰æŒ‘æˆ˜
- ç¡®ä¿ä½å¹»è§‰ç‡

---

### æ­¥éª¤2ï¼šç†è§£è¯„ä¼°(Comprehension Assessment)

**ç›®æ ‡**ï¼šè¯†åˆ«è®­ç»ƒæ¨¡å‹(Mtrain)çš„çŸ¥è¯†ç›²ç‚¹ï¼Œç¡®å®šéœ€è¦é’ˆå¯¹æ€§å¢å¼ºçš„çŸ¥è¯†ç‚¹

**ä»£ç å®ç°ä½ç½®**ï¼š
- ä¸»å…¥å£ï¼š`graphgen/graphgen.py::GraphGen.quiz_and_judge()`
- è¯­ä¹‰å˜ä½“ç”Ÿæˆï¼š`graphgen/operators/quiz.py`
- ç½®ä¿¡åº¦è¯„ä¼°ï¼š`graphgen/operators/judge.py`
- æŸå¤±è®¡ç®—ï¼š`graphgen/utils/calculate_confidence.py`

**è¯¦ç»†è¿‡ç¨‹**ï¼š

#### 1. å£°æ˜å¤„ç†

**å®ç°ä½ç½®**ï¼š`graphgen/operators/quiz.py::quiz()`

- å°†çŸ¥è¯†å›¾è°±ä¸­æ¯æ¡è¾¹çš„æè¿°è§†ä¸ºä¸€ä¸ªå£°æ˜æ€§é™ˆè¿°Ri
- è¯¥é™ˆè¿°ä»£è¡¨ä¸€ä¸ªæ— æ¡ä»¶ä¸ºçœŸçš„çŸ¥è¯†ç‚¹Ki(P(Ri is true)=1)
- å¯¹æ¯ä¸ªèŠ‚ç‚¹å’Œè¾¹çš„æè¿°è¿›è¡Œå¤„ç†

#### 2. è¯­ä¹‰å˜ä½“ç”Ÿæˆ

**å®ç°ä½ç½®**ï¼š`graphgen/operators/quiz.py::_process_single_quiz()`

- ä½¿ç”¨Msynthç”Ÿæˆå¤šä¸ªRiçš„é‡Šä¹‰ç‰ˆæœ¬(Ri1, Ri2,..., Rin)åŠå…¶å¦å®šå½¢å¼(Â¬Ri1,Â¬Ri2,...,Â¬Rin)
- æç¤ºæ¨¡æ¿ï¼š`graphgen/templates/description_rephrasing.py`
- æ”¯æŒä¸­è‹±æ–‡ä¸¤ç§è¯­è¨€

**ä»£ç ç¤ºä¾‹**ï¼š
```python
# graphgen/operators/quiz.py:59-80
for i in range(max_samples):
    if i > 0:
        # ç”Ÿæˆé‡Šä¹‰ç‰ˆæœ¬ï¼ˆground truth: "yes"ï¼‰
        tasks.append(_process_single_quiz(
            description,
            DESCRIPTION_REPHRASING_PROMPT[language]["TEMPLATE"].format(
                input_sentence=description
            ),
            "yes",
        ))
    # ç”Ÿæˆå¦å®šå½¢å¼ï¼ˆground truth: "no"ï¼‰
    tasks.append(_process_single_quiz(
        description,
        DESCRIPTION_REPHRASING_PROMPT[language]["ANTI_TEMPLATE"].format(
            input_sentence=description
        ),
        "no",
    ))
```

#### 3. ç½®ä¿¡åº¦è¯„ä¼°

**å®ç°ä½ç½®**ï¼š`graphgen/operators/judge.py::judge_statement()`

- é€šè¿‡äºŒå…ƒæ˜¯/å¦é—®é¢˜æç¤ºè·å–Mtrainå¯¹æ¯ä¸ªé™ˆè¿°çš„ç½®ä¿¡åº¦
- æç¤ºæ¨¡æ¿ï¼š`graphgen/templates/statement_judgement.py`
- ä½¿ç”¨ `generate_topk_per_token()` è·å–æ¨¡å‹å¯¹"yes"/"no"çš„tokenæ¦‚ç‡

**ä»£ç ç¤ºä¾‹**ï¼š
```python
# graphgen/operators/judge.py:56-64
for description, gt in descriptions:
    judgement = await trainee_llm_client.generate_topk_per_token(
        STATEMENT_JUDGEMENT_PROMPT["TEMPLATE"].format(
            statement=description
        )
    )
    judgements.append(judgement[0].top_candidates)
```

#### 4. ç†è§£æŸå¤±è®¡ç®—

**å®ç°ä½ç½®**ï¼š`graphgen/utils/calculate_confidence.py::yes_no_loss_entropy()`

- é€šè¿‡è®¡ç®—çœŸå®åˆ†å¸ƒä¸é¢„æµ‹åˆ†å¸ƒé—´çš„äº¤å‰ç†µå®šä¹‰ç†è§£æŸå¤±
- å…¬å¼å®ç°ï¼š
  ```python
  # graphgen/utils/calculate_confidence.py:52-64
  def yes_no_loss_entropy(tokens_list, ground_truth):
      losses = []
      for i, tokens in enumerate(tokens_list):
          token = tokens[0]
          if token.text == ground_truth[i]:
              losses.append(-math.log(token.prob))
          else:
              losses.append(-math.log(1 - token.prob))
      return sum(losses) / len(losses)
  ```

- è¯¥æŸå¤±è¡¡é‡æ¨¡å‹å½“å‰ç†è§£ä¸å®Œå…¨æŒæ¡çŸ¥è¯†ç‚¹é—´çš„å·®è·ï¼Œé«˜æŸå¤±å€¼è¡¨ç¤ºçŸ¥è¯†ç›²ç‚¹
- æŸå¤±å€¼å­˜å‚¨åœ¨çŸ¥è¯†å›¾è°±çš„è¾¹å±æ€§ä¸­ï¼š`edge_data["loss"]`

**é…ç½®å‚æ•°**ï¼š
```yaml
quiz_and_judge:
  enabled: true
  quiz_samples: 2        # æ¯ä¸ªè¾¹ç”Ÿæˆçš„è¯­ä¹‰å˜ä½“æ•°é‡
  re_judge: false        # æ˜¯å¦é‡æ–°è¯„ä¼°å·²æœ‰æ ·æœ¬
```

---

### æ­¥éª¤3ï¼šå›¾ç»„ç»‡(Graph Organization)

**ç›®æ ‡**ï¼šé€šè¿‡å­å›¾é‡‡æ ·æ•è·å¤æ‚å…³ç³»ä¿¡æ¯ï¼Œç¡®ä¿ç”Ÿæˆæ•°æ®çš„ä¸Šä¸‹æ–‡è¿è´¯æ€§

**ä»£ç å®ç°ä½ç½®**ï¼š
- ä¸»å…¥å£ï¼š`graphgen/graphgen.py::GraphGen.generate()` -> `graphgen/operators/partition/partition_kg.py`
- ECEåˆ†åŒºå™¨ï¼š`graphgen/models/partitioner/ece_partitioner.py`
- BFSåˆ†åŒºå™¨ï¼š`graphgen/models/partitioner/bfs_partitioner.py`
- DFSåˆ†åŒºå™¨ï¼š`graphgen/models/partitioner/dfs_partitioner.py`

**è¯¦ç»†è¿‡ç¨‹**ï¼š

#### 1. å­å›¾æå–

**å®ç°ä½ç½®**ï¼š`graphgen/models/partitioner/ece_partitioner.py::ECEPartitioner.partition()`

- ä½¿ç”¨k-hopå­å›¾æå–ç®—æ³•ç»„ç»‡çŸ¥è¯†
- ä»¥é«˜æŸå¤±è¾¹ä¸ºèµ·ç‚¹ï¼Œæ‰©å±•ç›¸å…³çŸ¥è¯†
- é‚»å±…è¾¹æ ¹æ®éå†ç­–ç•¥é€‰æ‹©

**æ ¸å¿ƒç®—æ³•**ï¼š
```python
# graphgen/models/partitioner/ece_partitioner.py:80-141
async def _grow_community(seed_unit):
    # ä½¿ç”¨BFSæ‰©å±•ç¤¾åŒº
    while not queue.empty():
        cur_type, cur_id, _ = await queue.get()
        # è·å–é‚»å±…å•å…ƒ
        neighbors = get_neighbors(cur_type, cur_id)
        # æ ¹æ®é‡‡æ ·ç­–ç•¥æ’åº
        neighbors = self._sort_units(neighbors, unit_sampling)
        # æ·»åŠ é‚»å±…åˆ°ç¤¾åŒº
        for nb in neighbors:
            if await _add_unit(nb):
                await queue.put(nb)
```

#### 2. éå†ç­–ç•¥

**å®ç°ä½ç½®**ï¼š`graphgen/models/partitioner/ece_partitioner.py::_sort_units()`

**æ·±åº¦ç­–ç•¥**ï¼š
- æ§åˆ¶k-hopæ·±åº¦ï¼Œç¡®ä¿å­å›¾è·¨è¶Šé¢„å®šä¹‰è·³æ•°
- é€šè¿‡BFSç®—æ³•å®ç°

**é•¿åº¦ç­–ç•¥**ï¼š
- é™åˆ¶å‰æé•¿åº¦(pre_lengthï¼Œå­å›¾ä¸­å®ä½“å’Œå…³ç³»æè¿°çš„æ€»tokenæ•°)
- å‚æ•°ï¼š`max_tokens_per_community`

**é€‰æ‹©ç­–ç•¥**ï¼šä¸‰ç§é€‰é¡¹æ§åˆ¶è¾¹é€‰æ‹©
- `max_loss`ï¼šä¼˜å…ˆé€‰æ‹©é«˜æŸå¤±è¾¹(æ›´å¤§ä¸ç¡®å®šæ€§)
- `min_loss`ï¼šä¼˜å…ˆé€‰æ‹©ä½æŸå¤±è¾¹(æ›´ç¨³å®šå…³ç³»)
- `random`ï¼šéšæœºé€‰æ‹©è¾¹

**ä»£ç å®ç°**ï¼š
```python
# graphgen/models/partitioner/ece_partitioner.py:29-52
@staticmethod
def _sort_units(units: list, edge_sampling: str) -> list:
    if edge_sampling == "random":
        random.shuffle(units)
    elif edge_sampling == "min_loss":
        units = sorted(units, key=lambda x: x[-1]["loss"])
    elif edge_sampling == "max_loss":
        units = sorted(units, key=lambda x: x[-1]["loss"], reverse=True)
    return units
```

#### 3. çº¦æŸæ£€æŸ¥

**å®ç°ä½ç½®**ï¼š`graphgen/models/partitioner/ece_partitioner.py::_grow_community()`

- å½“å­å›¾æ»¡è¶³é¢„è®¾çº¦æŸæ¡ä»¶æ—¶åœæ­¢æ‰©å±•
- çº¦æŸæ¡ä»¶ï¼š
  - `max_units_per_community`: æœ€å¤§å•å…ƒæ•°ï¼ˆèŠ‚ç‚¹+è¾¹ï¼‰
  - `min_units_per_community`: æœ€å°å•å…ƒæ•°
  - `max_tokens_per_community`: æœ€å¤§tokenæ•°

**é…ç½®å‚æ•°**ï¼ˆè§ `graphgen/configs/aggregated_config.yaml`ï¼‰ï¼š
```yaml
partition:
  method: ece
  method_params:
    max_units_per_community: 20
    min_units_per_community: 5
    max_tokens_per_community: 10240
    unit_sampling: max_loss  # random, min_loss, max_loss
```

---

### æ­¥éª¤4ï¼šQAç”Ÿæˆ(QA Generation)

**ç›®æ ‡**ï¼šå°†é‡‡æ ·å­å›¾è½¬æ¢ä¸ºå¤šæ ·åŒ–çš„QAå¯¹ï¼Œé€‚åº”ä¸åŒåœºæ™¯

**ä»£ç å®ç°ä½ç½®**ï¼š
- ä¸»å…¥å£ï¼š`graphgen/operators/generate/generate_qas.py`
- åŸå­ç”Ÿæˆå™¨ï¼š`graphgen/models/generator/atomic_generator.py`
- èšåˆç”Ÿæˆå™¨ï¼š`graphgen/models/generator/aggregated_generator.py`
- å¤šè·³ç”Ÿæˆå™¨ï¼š`graphgen/models/generator/multi_hop_generator.py`
- æç¤ºæ¨¡æ¿ï¼š`graphgen/templates/generation/`

**è¯¦ç»†è¿‡ç¨‹**ï¼š

#### 1. åŸå­QAç”Ÿæˆ

**å®ç°ä½ç½®**ï¼š`graphgen/models/generator/atomic_generator.py`

- é€‚ç”¨äºå•èŠ‚ç‚¹/è¾¹çš„å­å›¾
- ç”Ÿæˆä»£è¡¨åŸºæœ¬çŸ¥è¯†çš„ç®€å•QAå¯¹
- æç¤ºæ¨¡æ¿ï¼š`graphgen/templates/generation/atomic_generation.py`

**ä»£ç ç¤ºä¾‹**ï¼š
```python
# graphgen/models/generator/atomic_generator.py:10-22
def build_prompt(batch):
    nodes, edges = batch
    context = ""
    for node in nodes:
        context += f"- {node[0]}: {node[1]['description']}\n"
    for edge in edges:
        context += f"- {edge[0]} - {edge[1]}: {edge[2]['description']}\n"
    prompt = ATOMIC_GENERATION_PROMPT[language].format(context=context)
    return prompt
```

**é…ç½®**ï¼ˆè§ `graphgen/configs/atomic_config.yaml`ï¼‰ï¼š
```yaml
partition:
  method: dfs
  method_params:
    max_units_per_community: 1  # åŸå­åˆ†åŒºï¼Œæ¯ä¸ªç¤¾åŒºä¸€ä¸ªèŠ‚ç‚¹æˆ–è¾¹
generate:
  mode: atomic
```

#### 2. èšåˆQAç”Ÿæˆ

**å®ç°ä½ç½®**ï¼š`graphgen/models/generator/aggregated_generator.py`

- åˆ†æã€æ€»ç»“å­å›¾ä¸­å¤šä¸ªå®ä½“å’Œå…³ç³»
- å…ˆå°†çŸ¥è¯†ç»„ç»‡æˆè¿è´¯æ–‡æœ¬(ç­”æ¡ˆ)ï¼Œå†ç”Ÿæˆå¯¹åº”é—®é¢˜
- é€‚ç”¨äºéœ€è¦æ•´åˆå¤šæºä¿¡æ¯çš„åœºæ™¯

**ä»£ç æµç¨‹**ï¼š
```python
# graphgen/models/generator/aggregated_generator.py:98-127
async def generate(batch):
    # 1. æ„å»ºé‡è¿°æç¤ºï¼Œå°†å­å›¾è½¬æ¢ä¸ºè¿è´¯æ–‡æœ¬
    rephrasing_prompt = self.build_prompt(batch)
    response = await self.llm_client.generate_answer(rephrasing_prompt)
    context = self.parse_rephrased_text(response)
    
    # 2. åŸºäºè¿è´¯æ–‡æœ¬ç”Ÿæˆé—®é¢˜
    question_generation_prompt = self._build_prompt_for_question_generation(context)
    response = await self.llm_client.generate_answer(question_generation_prompt)
    question = self.parse_response(response)["question"]
```

**é…ç½®**ï¼ˆè§ `graphgen/configs/aggregated_config.yaml`ï¼‰ï¼š
```yaml
generate:
  mode: aggregated
```

#### 3. å¤šè·³QAç”Ÿæˆ

**å®ç°ä½ç½®**ï¼š`graphgen/models/generator/multi_hop_generator.py`

- æ¾„æ¸…å®ä½“é—´å…³ç³»è·¯å¾„
- ç”Ÿæˆéœ€è¦å¤šæ­¥æ¨ç†çš„QAå¯¹
- ä¾‹ï¼š"Ed Woodç”µå½±çš„å¯¼æ¼”æ˜¯è°ï¼Œä»–è¿˜å¯¼æ¼”äº†å“ªäº›çŸ¥åç”µå½±ï¼Ÿ"

**é…ç½®**ï¼ˆè§ `graphgen/configs/multi_hop_config.yaml`ï¼‰ï¼š
```yaml
partition:
  method: ece
  method_params:
    max_units_per_community: 3  # å¤šè·³æ¨èè®¾ç½®ä¸º3
    min_units_per_community: 3
    unit_sampling: random
generate:
  mode: multi_hop
```

#### 4. è¾“å‡ºæ ¼å¼

**å®ç°ä½ç½®**ï¼š`graphgen/bases/base_generator.py::format_generation_results()`

æ”¯æŒå¤šç§è¾“å‡ºæ ¼å¼ï¼š
- **Alpacaæ ¼å¼**ï¼šç”¨äºAlpacaæ•°æ®é›†
- **ShareGPTæ ¼å¼**ï¼šç”¨äºå¯¹è¯æ•°æ®é›†
- **ChatMLæ ¼å¼**ï¼šç”¨äºOpenAIæ ¼å¼

---

## ä¸‰ã€æŠ€æœ¯å®ç°ç»†èŠ‚

### æ¨¡å‹é…ç½®

**ä»£ç ä½ç½®**ï¼š`graphgen/graphgen.py::GraphGen.__post_init__()`

- **åˆæˆå™¨æ¨¡å‹(Msynth)**ï¼šQwen2.5-72B-Instructï¼ˆè´Ÿè´£çŸ¥è¯†æå–å’Œé‡è¿°ï¼‰
  - é€šè¿‡ç¯å¢ƒå˜é‡ `SYNTHESIZER_MODEL`ã€`SYNTHESIZER_BASE_URL`ã€`SYNTHESIZER_API_KEY` é…ç½®
  
- **è®­ç»ƒæ¨¡å‹(Mtrain)**ï¼šQwen2.5-7B-Instructï¼ˆç›®æ ‡ä¼˜åŒ–æ¨¡å‹ï¼‰
  - é€šè¿‡ç¯å¢ƒå˜é‡ `TRAINEE_MODEL`ã€`TRAINEE_BASE_URL`ã€`TRAINEE_API_KEY` é…ç½®

### å‚æ•°è®¾ç½®

**é»˜è®¤é…ç½®**ï¼ˆè§å„é…ç½®æ–‡ä»¶ï¼‰ï¼š
- å›¾ç»„ç»‡ç­–ç•¥ï¼š
  - `pre_length=256`ï¼ˆé€šè¿‡ `max_tokens_per_community` æ§åˆ¶ï¼‰
  - `max_depth=2`ï¼ˆé€šè¿‡BFSç®—æ³•éšå¼æ§åˆ¶ï¼‰
  - `bidirectional=True`ï¼ˆBFSè‡ªç„¶æ”¯æŒï¼‰
  
- è¾¹é€‰æ‹©ç­–ç•¥ï¼šé»˜è®¤ `max_loss`ï¼ˆä¼˜å…ˆé«˜æŸå¤±è¾¹ï¼‰
  ```yaml
  partition:
    method_params:
      unit_sampling: max_loss  # random, min_loss, max_loss
  ```

- ç”Ÿæˆå‚æ•°ï¼š
  - `temperature=0`ï¼ˆç¡®å®šæ€§ç”Ÿæˆï¼Œåœ¨ `judge_statement` ä¸­ä½¿ç”¨ï¼‰
  - `repetition_penalty=1.05`ï¼ˆåœ¨LLMå®¢æˆ·ç«¯é…ç½®ï¼‰

### è¯„ä¼°æŒ‡æ ‡

**ä»£ç ä½ç½®**ï¼š`graphgen/evaluate.py`

- **çŸ¥è¯†è´¨é‡**ï¼š
  - ROUGE-Fï¼šè¯„ä¼°ç”Ÿæˆæ–‡æœ¬ä¸å‚è€ƒæ–‡æœ¬çš„é‡å åº¦
  - äº‹å®å‡†ç¡®æ€§ï¼šè¯„ä¼°ç”Ÿæˆå†…å®¹çš„äº‹å®æ­£ç¡®æ€§

- **æ–‡æœ¬è´¨é‡**ï¼š
  - MTLDï¼ˆè¯æ±‡å¤šæ ·æ€§ï¼‰ï¼š`graphgen/models/evaluator/mtld_evaluator.py`
  - UniEvalï¼ˆè‡ªç„¶æ€§ã€è¿è´¯æ€§ã€ç†è§£æ€§ï¼‰ï¼š`graphgen/models/evaluator/uni_evaluator.py`

- **å¥–åŠ±æ¨¡å‹è¯„åˆ†**ï¼š
  - Indå’ŒDebä¸¤ä¸ªå¥–åŠ±æ¨¡å‹ï¼š`graphgen/models/evaluator/reward_evaluator.py`

### å­˜å‚¨ç³»ç»Ÿ

**ä»£ç ä½ç½®**ï¼š`graphgen/models/storage/`

- **æ–‡æ¡£å­˜å‚¨**ï¼š`JsonKVStorage` - å­˜å‚¨åŸå§‹æ–‡æ¡£å’Œåˆ†å—
- **å›¾è°±å­˜å‚¨**ï¼š`NetworkXStorage` - ä½¿ç”¨NetworkXå­˜å‚¨çŸ¥è¯†å›¾è°±
- **é‡è¿°å­˜å‚¨**ï¼š`JsonKVStorage` - å­˜å‚¨è¯­ä¹‰å˜ä½“
- **QAå­˜å‚¨**ï¼š`JsonListStorage` - å­˜å‚¨ç”Ÿæˆçš„QAå¯¹

---

## å››ã€å·¥ä½œæµç¨‹æ€»ç»“

### å®Œæ•´æµç¨‹ä»£ç è°ƒç”¨é“¾

```
GraphGen.insert()
  â”œâ”€â”€ read_files()                    # è¯»å–æ–‡ä»¶
  â”œâ”€â”€ chunk_documents()               # æ–‡æ¡£åˆ†å‰²
  â””â”€â”€ build_text_kg() / build_mm_kg() # çŸ¥è¯†æå–
      â””â”€â”€ LightRAGKGBuilder.extract() # LLMæå–å®ä½“å…³ç³»
          â””â”€â”€ merge_nodes() / merge_edges() # çŸ¥è¯†èšåˆ

GraphGen.quiz_and_judge()
  â”œâ”€â”€ quiz()                          # ç”Ÿæˆè¯­ä¹‰å˜ä½“
  â””â”€â”€ judge_statement()               # è¯„ä¼°ç½®ä¿¡åº¦
      â””â”€â”€ yes_no_loss_entropy()       # è®¡ç®—ç†è§£æŸå¤±

GraphGen.generate()
  â”œâ”€â”€ partition_kg()                  # å›¾ç»„ç»‡
  â”‚   â””â”€â”€ ECEPartitioner.partition()  # ECEåˆ†åŒºç®—æ³•
  â””â”€â”€ generate_qas()                 # QAç”Ÿæˆ
      â”œâ”€â”€ AtomicGenerator.generate()
      â”œâ”€â”€ AggregatedGenerator.generate()
      â””â”€â”€ MultiHopGenerator.generate()
```

### å…³é”®è®¾è®¡æ¨¡å¼

1. **å¼‚æ­¥å¹¶å‘å¤„ç†**ï¼šä½¿ç”¨ `asyncio` å’Œ `run_concurrent()` å®ç°é«˜å¹¶å‘
2. **å­˜å‚¨æŠ½è±¡**ï¼šé€šè¿‡ `BaseStorage` æ¥å£æ”¯æŒå¤šç§å­˜å‚¨åç«¯
3. **ç”Ÿæˆå™¨æ¨¡å¼**ï¼šé€šè¿‡ `BaseGenerator` æ¥å£æ”¯æŒå¤šç§QAç”Ÿæˆæ¨¡å¼
4. **åˆ†åŒºå™¨æ¨¡å¼**ï¼šé€šè¿‡ `BasePartitioner` æ¥å£æ”¯æŒå¤šç§å›¾åˆ†åŒºç­–ç•¥

---

## äº”ã€æ‰©å±•ä¸å®šåˆ¶

### æ·»åŠ æ–°çš„QAç”Ÿæˆæ¨¡å¼

1. ç»§æ‰¿ `BaseGenerator` ç±»
2. å®ç° `build_prompt()` å’Œ `parse_response()` æ–¹æ³•
3. åœ¨ `generate_qas()` ä¸­æ³¨å†Œæ–°ç”Ÿæˆå™¨

### æ·»åŠ æ–°çš„å›¾åˆ†åŒºç­–ç•¥

1. ç»§æ‰¿ `BasePartitioner` ç±»
2. å®ç° `partition()` æ–¹æ³•
3. åœ¨ `partition_kg()` ä¸­æ³¨å†Œæ–°åˆ†åŒºå™¨

### æ·»åŠ æ–°çš„è¯„ä¼°æŒ‡æ ‡

1. ç»§æ‰¿ `BaseEvaluator` ç±»
2. å®ç°è¯„ä¼°é€»è¾‘
3. åœ¨ `evaluate.py` ä¸­é›†æˆ

---

## å…­ã€ä¼˜åŒ–å»ºè®®

åŸºäºå¯¹GraphGenæ¡†æ¶çš„è¯¦ç»†è§£æï¼Œä»**æ•ˆç‡**å’Œ**ç”Ÿæˆè´¨é‡**ä¸¤ä¸ªç»´åº¦æå‡ºä»¥ä¸‹ä¼˜åŒ–å»ºè®®ã€‚è¿™äº›å»ºè®®ç»“åˆäº†æ¡†æ¶çš„å®é™…å®ç°ï¼ˆå¦‚ä»£ç ç»“æ„ã€ç®—æ³•ç­–ç•¥å’Œé…ç½®å‚æ•°ï¼‰ï¼Œæ—¨åœ¨æå‡æ•´ä½“æ€§èƒ½è€Œä¸æ”¹å˜æ ¸å¿ƒæ¶æ„ã€‚

### ä¸€ã€æ•ˆç‡ä¼˜åŒ–å»ºè®®

æ•ˆç‡ä¼˜åŒ–ä¸»è¦å…³æ³¨**è®¡ç®—èµ„æºæ¶ˆè€—ã€å¤„ç†é€Ÿåº¦å’Œå¯æ‰©å±•æ€§**ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤§è§„æ¨¡çŸ¥è¯†å›¾è°±å’ŒLLMè°ƒç”¨åœºæ™¯ä¸‹ã€‚

#### 1. å¹¶è¡Œä¸å¼‚æ­¥å¤„ç†ä¼˜åŒ–

**ç°çŠ¶åˆ†æ**ï¼š
- æ¡†æ¶å·²ä½¿ç”¨`asyncio`å’Œ`run_concurrent()`ï¼ˆè§`graphgen/utils/run_concurrent.py`ï¼‰
- çŸ¥è¯†æå–é˜¶æ®µå·²å®ç°å¹¶è¡Œå¤„ç†ï¼ˆè§`graphgen/operators/build_kg/build_text_kg.py:26-32`ï¼‰
- LLMè°ƒç”¨æœ‰é€Ÿç‡é™åˆ¶æœºåˆ¶ï¼ˆè§`graphgen/models/llm/limitter.py`ï¼‰

**ä¼˜åŒ–å»ºè®®**ï¼š

**A. ç»†ç²’åº¦å¹¶è¡ŒåŒ–å¢å¼º**
- **ä½ç½®**ï¼š`graphgen/models/kg_builder/light_rag_kg_builder.py::extract()`
- **å»ºè®®**ï¼šåœ¨çŸ¥è¯†æå–é˜¶æ®µï¼Œå¯¹å¤šä¸ªæ–‡æ¡£å—å¹¶è¡Œå¤„ç†ï¼Œå½“å‰å·²å®ç°ï¼Œä½†å¯ä¼˜åŒ–ï¼š
  ```python
  # å½“å‰å®ç°å·²ä½¿ç”¨ run_concurrentï¼Œä½†å¯å¢åŠ æ‰¹é‡å¤§å°æ§åˆ¶
  # å»ºè®®ï¼šæ ¹æ®LLMæœåŠ¡çš„å¹¶å‘èƒ½åŠ›åŠ¨æ€è°ƒæ•´æ‰¹é‡å¤§å°
  batch_size = min(len(chunks), max_concurrent_capacity)
  results = await run_concurrent(
      kg_builder.extract,
      chunks,
      desc="[2/4]Extracting entities and relationships from chunks",
      unit="chunk",
      progress_bar=self.progress_bar,
  )
  ```

**B. æ‰¹é‡LLMè°ƒç”¨ä¼˜åŒ–**
- **ä½ç½®**ï¼š`graphgen/operators/quiz.py` å’Œ `graphgen/operators/generate/generate_qas.py`
- **å»ºè®®**ï¼šåœ¨ç”Ÿæˆè¯­ä¹‰å˜ä½“å’ŒQAå¯¹æ—¶ï¼Œå°†å¤šä¸ªè¯·æ±‚åˆå¹¶ä¸ºå•ä¸ªæ‰¹é‡APIè°ƒç”¨ï¼Œå‡å°‘ç½‘ç»œå»¶è¿Ÿ
  ```python
  # å½“å‰ï¼šé€ä¸ªè°ƒç”¨
  # ä¼˜åŒ–ï¼šæ‰¹é‡è°ƒç”¨ï¼ˆå¦‚æœLLM APIæ”¯æŒï¼‰
  async def batch_quiz(descriptions: List[str], prompts: List[str]):
      # åˆå¹¶å¤šä¸ªè¯·æ±‚ä¸ºæ‰¹é‡APIè°ƒç”¨
      batch_requests = [
          {"prompt": p, "description": d} 
          for p, d in zip(prompts, descriptions)
      ]
      results = await llm_client.generate_batch(batch_requests)
      return results
  ```

**C. åŠ¨æ€å¹¶å‘æ§åˆ¶**
- **ä½ç½®**ï¼š`graphgen/models/llm/limitter.py` å’Œ `graphgen/utils/run_concurrent.py`
- **å»ºè®®**ï¼šæ ¹æ®LLMæœåŠ¡çš„é€Ÿç‡é™åˆ¶åŠ¨æ€è°ƒæ•´å¹¶å‘æ•°ï¼Œé¿å…è¶…è½½
  ```python
  # åœ¨ run_concurrent ä¸­é›†æˆåŠ¨æ€å¹¶å‘æ§åˆ¶
  class AdaptiveConcurrencyController:
      def __init__(self, initial_concurrency=10):
          self.current_concurrency = initial_concurrency
          self.success_rate = 1.0
      
      async def adjust_concurrency(self, success_rate):
          if success_rate < 0.8:
              self.current_concurrency = max(1, int(self.current_concurrency * 0.8))
          elif success_rate > 0.95:
              self.current_concurrency = min(100, int(self.current_concurrency * 1.1))
  ```

#### 2. ç¼“å­˜ä¸å­˜å‚¨ä¼˜åŒ–

**ç°çŠ¶åˆ†æ**ï¼š
- ä½¿ç”¨`JsonKVStorage`å’Œ`NetworkXStorage`ï¼ˆè§`graphgen/models/storage/`ï¼‰
- å·²æœ‰åŸºæœ¬çš„è¿‡æ»¤æœºåˆ¶é¿å…é‡å¤å¤„ç†ï¼ˆè§`graphgen/graphgen.py:103-104`ï¼‰
- ä½†æœªæ˜¾å¼ç¼“å­˜ä¸­é—´ç»“æœ

**ä¼˜åŒ–å»ºè®®**ï¼š

**A. å®ä½“/å…³ç³»ç¼“å­˜**
- **ä½ç½®**ï¼š`graphgen/models/kg_builder/light_rag_kg_builder.py`
- **å»ºè®®**ï¼šåœ¨çŸ¥è¯†æ„å»ºé˜¶æ®µï¼Œå¯¹å·²æå–çš„å®ä½“å’Œå…³ç³»è¿›è¡Œç¼“å­˜ï¼ˆåŸºäºæ–‡æœ¬å“ˆå¸Œï¼‰ï¼Œé¿å…é‡å¤æå–
  ```python
  # æ·»åŠ ç¼“å­˜å±‚
  class CachedKGBuilder(LightRAGKGBuilder):
      def __init__(self, llm_client, cache_storage):
          super().__init__(llm_client)
          self.cache = cache_storage
      
      async def extract(self, chunk: Chunk):
          chunk_hash = compute_content_hash(chunk.content)
          cached_result = await self.cache.get_by_id(chunk_hash)
          if cached_result:
              return cached_result
          
          result = await super().extract(chunk)
          await self.cache.upsert({chunk_hash: result})
          return result
  ```

**B. å­å›¾é‡‡æ ·ç¼“å­˜**
- **ä½ç½®**ï¼š`graphgen/models/partitioner/ece_partitioner.py`
- **å»ºè®®**ï¼šå¯¹é¢‘ç¹è®¿é—®çš„å­å›¾ç»“æ„ç¼“å­˜é‡‡æ ·ç»“æœï¼Œå‡å°‘é‡å¤è®¡ç®—
  ```python
  # åœ¨ ECEPartitioner ä¸­æ·»åŠ ç¼“å­˜
  class CachedECEPartitioner(ECEPartitioner):
      def __init__(self, cache_storage):
          super().__init__()
          self.cache = cache_storage
      
      async def partition(self, g, **kwargs):
          graph_hash = compute_graph_hash(g)
          cached_communities = await self.cache.get_by_id(graph_hash)
          if cached_communities:
              return cached_communities
          
          communities = await super().partition(g, **kwargs)
          await self.cache.upsert({graph_hash: communities})
          return communities
  ```

**C. åˆ†å¸ƒå¼å­˜å‚¨**
- **ä½ç½®**ï¼š`graphgen/models/storage/`
- **å»ºè®®**ï¼šå¯¹äºè¶…å¤§è§„æ¨¡å›¾è°±ï¼Œæ”¹ç”¨å›¾æ•°æ®åº“ï¼ˆå¦‚Neo4jï¼‰æˆ–åˆ†å¸ƒå¼å­˜å‚¨ï¼ˆå¦‚Redisï¼‰ï¼Œæå‡æŸ¥è¯¢æ•ˆç‡
  ```python
  # å®ç° Neo4jStorage ä½œä¸º BaseGraphStorage çš„å®ç°
  class Neo4jStorage(BaseGraphStorage):
      def __init__(self, uri, user, password):
          self.driver = GraphDatabase.driver(uri, auth=(user, password))
      
      async def add_node(self, node_id, data):
          # ä½¿ç”¨CypheræŸ¥è¯¢è¯­è¨€é«˜æ•ˆå­˜å‚¨
          query = "CREATE (n:Entity {id: $id, data: $data})"
          # ...
  ```

#### 3. ç®—æ³•ä¸ç­–ç•¥ä¼˜åŒ–

**ç°çŠ¶åˆ†æ**ï¼š
- å›¾ç»„ç»‡ä½¿ç”¨BFSå’ŒECEåˆ†åŒºï¼ˆè§`graphgen/models/partitioner/ece_partitioner.py`ï¼‰
- å·²æœ‰è¾¹é€‰æ‹©ç­–ç•¥ï¼ˆmax_loss/min_loss/randomï¼‰
- åœ¨å¤§å›¾ä¸Šå¯èƒ½æ•ˆç‡è¾ƒä½

**ä¼˜åŒ–å»ºè®®**ï¼š

**A. å¯å‘å¼é‡‡æ ·**
- **ä½ç½®**ï¼š`graphgen/models/partitioner/ece_partitioner.py::_grow_community()`
- **å»ºè®®**ï¼šåœ¨å­å›¾æ‰©å±•æ—¶ï¼Œä½¿ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆåŸºäºæŸå¤±å€¼ï¼‰æ›¿ä»£ç®€å•BFSï¼Œä¼˜å…ˆæ‰©å±•é«˜ä»·å€¼è¾¹
  ```python
  import heapq
  
  async def _grow_community_priority_queue(self, seed_unit):
      # ä½¿ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—æ›¿ä»£æ™®é€šé˜Ÿåˆ—
      priority_queue = []
      heapq.heappush(priority_queue, (-seed_unit[-1]["loss"], seed_unit))
      
      while priority_queue:
          neg_loss, unit = heapq.heappop(priority_queue)
          # å¤„ç†å•å…ƒå¹¶æ·»åŠ é‚»å±…åˆ°ä¼˜å…ˆçº§é˜Ÿåˆ—
          neighbors = self._get_neighbors(unit)
          for nb in neighbors:
              priority = -nb[-1]["loss"]  # è´Ÿå·å› ä¸ºheapqæ˜¯æœ€å°å †
              heapq.heappush(priority_queue, (priority, nb))
  ```

**B. æå‰ç»ˆæ­¢**
- **ä½ç½®**ï¼š`graphgen/models/partitioner/ece_partitioner.py::_grow_community()`
- **å»ºè®®**ï¼šåœ¨å­å›¾ç”Ÿé•¿è¿‡ç¨‹ä¸­ï¼Œè‹¥å½“å‰å­å›¾å·²æ»¡è¶³è´¨é‡é˜ˆå€¼ï¼ˆå¦‚æŸå¤±é™ä½åˆ°ä¸€å®šæ°´å¹³ï¼‰ï¼Œæå‰ç»ˆæ­¢æ‰©å±•
  ```python
  async def _grow_community(self, seed_unit):
      # ... ç°æœ‰ä»£ç  ...
      while not queue.empty():
          # è®¡ç®—å½“å‰ç¤¾åŒºçš„å¹³å‡æŸå¤±
          avg_loss = sum(e[-1].get("loss", 0) for e in community_edges.values()) / len(community_edges)
          if avg_loss < quality_threshold:  # è´¨é‡é˜ˆå€¼
              logger.info("Quality threshold reached, early stopping")
              break
          # ... ç»§ç»­æ‰©å±• ...
  ```

**C. è¿‘ä¼¼ç®—æ³•**
- **ä½ç½®**ï¼š`graphgen/models/partitioner/`
- **å»ºè®®**ï¼šå¯¹äºæå¤§å›¾è°±ï¼Œä½¿ç”¨å±€éƒ¨èšç±»ç³»æ•°ï¼ˆå¦‚Louvainç®—æ³•ï¼‰å¿«é€Ÿè¯†åˆ«ç¤¾åŒºï¼Œæ›¿ä»£ç²¾ç¡®çš„k-hopé‡‡æ ·
  ```python
  # å®ç° LouvainPartitioner
  class LouvainPartitioner(BasePartitioner):
      async def partition(self, g, **kwargs):
          import networkx as nx
          import community as community_louvain
          
          nx_graph = g.to_networkx()
          communities_dict = community_louvain.best_partition(nx_graph)
          # è½¬æ¢ä¸º Community å¯¹è±¡
          # ...
  ```

#### 4. èµ„æºç®¡ç†ä¸é…ç½®è°ƒä¼˜

**ç°çŠ¶åˆ†æ**ï¼š
- é…ç½®å‚æ•°å›ºå®šï¼ˆå¦‚`max_tokens_per_community=10240`ï¼Œè§`graphgen/configs/aggregated_config.yaml`ï¼‰
- å¯èƒ½ä¸é€‚ç”¨äºæ‰€æœ‰åœºæ™¯

**ä¼˜åŒ–å»ºè®®**ï¼š

**A. åŠ¨æ€å‚æ•°è°ƒæ•´**
- **ä½ç½®**ï¼š`graphgen/operators/split/split_chunks.py` å’Œ `graphgen/models/partitioner/ece_partitioner.py`
- **å»ºè®®**ï¼šæ ¹æ®è¾“å…¥æ–‡æœ¬é•¿åº¦å’Œå¤æ‚åº¦åŠ¨æ€è°ƒæ•´`chunk_size`ã€`max_tokens_per_community`ç­‰å‚æ•°
  ```python
  def calculate_optimal_chunk_size(text_length, complexity_score):
      """æ ¹æ®æ–‡æœ¬é•¿åº¦å’Œå¤æ‚åº¦åŠ¨æ€è®¡ç®—chunk_size"""
      base_size = 1024
      if text_length > 100000:
          base_size = 2048
      if complexity_score > 0.8:
          base_size = int(base_size * 0.8)  # å¤æ‚æ–‡æœ¬ä½¿ç”¨æ›´å°çš„chunk
      return base_size
  ```

**B. GPUå†…å­˜ä¼˜åŒ–**
- **ä½ç½®**ï¼šè®­ç»ƒé˜¶æ®µï¼ˆä¸åœ¨å½“å‰ä»£ç åº“ä¸­ï¼Œä½†å»ºè®®åœ¨SFTé˜¶æ®µä½¿ç”¨ï¼‰
- **å»ºè®®**ï¼šåœ¨SFTé˜¶æ®µä½¿ç”¨æ¢¯åº¦ç´¯ç§¯å’Œæ··åˆç²¾åº¦è®­ç»ƒï¼Œå‡å°‘æ˜¾å­˜å ç”¨

**C. æµæ°´çº¿å¤„ç†**
- **ä½ç½®**ï¼š`graphgen/graphgen.py`
- **å»ºè®®**ï¼šå°†çŸ¥è¯†æ„å»ºã€è¯„ä¼°ã€ç”Ÿæˆé˜¶æ®µè§£è€¦ä¸ºç‹¬ç«‹æµæ°´çº¿ï¼Œæ”¯æŒå¢é‡å¤„ç†
  ```python
  class PipelineGraphGen(GraphGen):
      async def process_incremental(self, new_docs):
          # å¢é‡å¤„ç†æ–°æ–‡æ¡£
          await self.insert(new_docs)
          # åªå¯¹æ–°å¢éƒ¨åˆ†è¿›è¡Œè¯„ä¼°å’Œç”Ÿæˆ
          new_edges = await self.get_new_edges()
          await self.quiz_and_judge(new_edges)
          await self.generate(new_edges)
  ```

---

### äºŒã€ç”Ÿæˆè´¨é‡ä¼˜åŒ–å»ºè®®

ç”Ÿæˆè´¨é‡ä¼˜åŒ–èšç„¦äº**äº‹å®å‡†ç¡®æ€§ã€å¤šæ ·æ€§ã€é•¿å°¾è¦†ç›–å’Œé€»è¾‘ä¸€è‡´æ€§**ã€‚

#### 1. äº‹å®å‡†ç¡®æ€§æå‡

**ç°çŠ¶åˆ†æ**ï¼š
- ä¾èµ–LLMæå–å’Œç”Ÿæˆï¼ˆè§`graphgen/models/kg_builder/`å’Œ`graphgen/models/generator/`ï¼‰
- å¯èƒ½ä»æœ‰å¹»è§‰é—®é¢˜

**ä¼˜åŒ–å»ºè®®**ï¼š

**A. å¤šæºéªŒè¯**
- **ä½ç½®**ï¼š`graphgen/operators/search/search_all.py`
- **å»ºè®®**ï¼šåœ¨å®ä½“ä¸°å¯Œæ¨¡å—ä¸­ï¼Œé›†æˆæ›´å¤šå¤–éƒ¨çŸ¥è¯†æºï¼ˆå¦‚é¢†åŸŸçŸ¥è¯†åº“ã€å­¦æœ¯è®ºæ–‡ï¼‰ï¼Œäº¤å‰éªŒè¯ç”Ÿæˆå†…å®¹
  ```python
  async def multi_source_verify(entity_name, extracted_info):
      """å¤šæºéªŒè¯å®ä½“ä¿¡æ¯"""
      sources = []
      # 1. æœç´¢Wikipedia
      wiki_result = await search_wikipedia(entity_name)
      # 2. æœç´¢é¢†åŸŸçŸ¥è¯†åº“
      domain_result = await search_domain_kb(entity_name)
      # 3. äº¤å‰éªŒè¯
      verified_info = cross_validate(extracted_info, [wiki_result, domain_result])
      return verified_info
  ```

**B. ä¸€è‡´æ€§æ£€æŸ¥**
- **ä½ç½®**ï¼š`graphgen/models/generator/` å’Œ `graphgen/evaluate.py`
- **å»ºè®®**ï¼šåœ¨QAç”Ÿæˆåï¼Œä½¿ç”¨å°è§„æ¨¡åˆ¤åˆ«æ¨¡å‹ï¼ˆå¦‚DeBERTaï¼‰å¯¹ç”Ÿæˆç­”æ¡ˆè¿›è¡Œäº‹å®ä¸€è‡´æ€§è¯„åˆ†ï¼Œè¿‡æ»¤ä½åˆ†æ ·æœ¬
  ```python
  class FactualConsistencyChecker:
      def __init__(self, model_path):
          self.model = load_model(model_path)  # DeBERTaç­‰åˆ¤åˆ«æ¨¡å‹
      
      async def check_consistency(self, qa_pair, source_context):
          """æ£€æŸ¥QAå¯¹ä¸æºä¸Šä¸‹æ–‡çš„ä¸€è‡´æ€§"""
          score = self.model.predict(qa_pair, source_context)
          return score > 0.7  # é˜ˆå€¼å¯è°ƒ
  ```

**C. è¿­ä»£ä¿®æ­£**
- **ä½ç½®**ï¼š`graphgen/graphgen.py::generate()`
- **å»ºè®®**ï¼šå¼•å…¥åé¦ˆå¾ªç¯ï¼Œä½¿ç”¨è®­ç»ƒåçš„æ¨¡å‹å¯¹ç”Ÿæˆæ•°æ®é‡æ–°è¯„åˆ†ï¼Œè¿­ä»£ä¼˜åŒ–
  ```python
  async def iterative_refinement(self, qa_pairs, max_iterations=3):
      """è¿­ä»£ä¼˜åŒ–QAå¯¹è´¨é‡"""
      for iteration in range(max_iterations):
          scores = await self.evaluate_qa_pairs(qa_pairs)
          low_quality = [qa for qa, score in zip(qa_pairs, scores) if score < 0.6]
          if not low_quality:
              break
          # é‡æ–°ç”Ÿæˆä½è´¨é‡æ ·æœ¬
          refined = await self.regenerate_qa_pairs(low_quality)
          qa_pairs = [r if r in refined else qa for qa, r in zip(qa_pairs, refined)]
      return qa_pairs
  ```

#### 2. å¤šæ ·æ€§ä¸é£æ ¼æ§åˆ¶

**ç°çŠ¶åˆ†æ**ï¼š
- ä½¿ç”¨é£æ ¼æ§åˆ¶ç”Ÿæˆï¼ˆè§`graphgen/templates/generation/`ï¼‰
- ä½†æ¨¡æ¿è¾ƒä¸ºå›ºå®š

**ä¼˜åŒ–å»ºè®®**ï¼š

**A. å¤šæ¨¡æ¿é‡‡æ ·**
- **ä½ç½®**ï¼š`graphgen/templates/generation/atomic_generation.py`ç­‰
- **å»ºè®®**ï¼šä¸ºæ¯ç§QAç±»å‹è®¾è®¡å¤šä¸ªæç¤ºæ¨¡æ¿ï¼Œéšæœºé‡‡æ ·ä½¿ç”¨ï¼Œé¿å…æ¨¡å¼åŒ–è¾“å‡º
  ```python
  class MultiTemplateGenerator(AtomicGenerator):
      def __init__(self, llm_client, templates):
          super().__init__(llm_client)
          self.templates = templates  # å¤šä¸ªæ¨¡æ¿åˆ—è¡¨
      
      def build_prompt(self, batch):
          # éšæœºé€‰æ‹©ä¸€ä¸ªæ¨¡æ¿
          template = random.choice(self.templates)
          return template.format(context=self._format_context(batch))
  ```

**B. æ§åˆ¶ç”Ÿæˆæ¸©åº¦**
- **ä½ç½®**ï¼š`graphgen/models/llm/openai_client.py::_pre_generate()`
- **å»ºè®®**ï¼šåœ¨QAç”Ÿæˆé˜¶æ®µï¼Œå¯¹`temperature`å‚æ•°è¿›è¡Œè°ƒåº¦ï¼ˆå¦‚ä»é«˜åˆ°ä½ï¼‰ï¼Œå¹³è¡¡å¤šæ ·æ€§å’Œå‡†ç¡®æ€§
  ```python
  class TemperatureScheduler:
      def __init__(self, initial_temp=1.0, final_temp=0.3, decay_rate=0.1):
          self.initial_temp = initial_temp
          self.final_temp = final_temp
          self.decay_rate = decay_rate
          self.step = 0
      
      def get_temperature(self):
          temp = self.initial_temp * (self.decay_rate ** self.step)
          return max(temp, self.final_temp)
      
      def step(self):
          self.step += 1
  ```

**C. å¯¹æŠ—è®­ç»ƒ**
- **ä½ç½®**ï¼šè®­ç»ƒé˜¶æ®µï¼ˆä¸åœ¨å½“å‰ä»£ç åº“ä¸­ï¼‰
- **å»ºè®®**ï¼šåœ¨SFTé˜¶æ®µå¼•å…¥å¯¹æŠ—æ ·æœ¬ï¼Œå¢å¼ºæ¨¡å‹å¯¹å¤šæ ·åŒ–è¾“å…¥çš„é²æ£’æ€§

#### 3. é•¿å°¾çŸ¥è¯†è¦†ç›–

**ç°çŠ¶åˆ†æ**ï¼š
- ä½¿ç”¨ECEè¯†åˆ«ç›²ç‚¹ï¼ˆè§`graphgen/operators/judge.py`ï¼‰
- é‡‡æ ·ç­–ç•¥å·²æœ‰max_lossé€‰é¡¹ï¼ˆè§`graphgen/models/partitioner/ece_partitioner.py::_sort_units()`ï¼‰

**ä¼˜åŒ–å»ºè®®**ï¼š

**A. ä¸»åŠ¨å­¦ä¹ **
- **ä½ç½®**ï¼š`graphgen/models/partitioner/ece_partitioner.py`
- **å»ºè®®**ï¼šåœ¨ç†è§£è¯„ä¼°é˜¶æ®µï¼Œä¸ä»…åŸºäºæŸå¤±æ’åºï¼Œè¿˜ç»“åˆä¿¡æ¯å¢ç›Šï¼ˆå¦‚ç†µå€¼ï¼‰é€‰æ‹©æ ·æœ¬
  ```python
  def calculate_information_gain(edge, current_knowledge):
      """è®¡ç®—é€‰æ‹©è¯¥è¾¹çš„ä¿¡æ¯å¢ç›Š"""
      loss = edge[-1]["loss"]
      entropy = calculate_entropy(edge, current_knowledge)
      information_gain = loss * entropy  # ç»¼åˆæŸå¤±å’Œç†µ
      return information_gain
  
  def _sort_units_by_information_gain(self, units):
      """åŸºäºä¿¡æ¯å¢ç›Šæ’åº"""
      return sorted(units, key=lambda x: calculate_information_gain(x, self.current_knowledge), reverse=True)
  ```

**B. åˆæˆå¢å¼º**
- **ä½ç½®**ï¼š`graphgen/operators/quiz.py`
- **å»ºè®®**ï¼šå¯¹é•¿å°¾çŸ¥è¯†ç‚¹ï¼Œä½¿ç”¨æ•°æ®å¢å¼ºæŠ€æœ¯ï¼ˆå¦‚å›è¯‘ã€å®ä½“æ›¿æ¢ï¼‰ç”Ÿæˆæ›´å¤šå˜ä½“
  ```python
  async def augment_long_tail_knowledge(edge, max_variants=5):
      """ä¸ºé•¿å°¾çŸ¥è¯†ç”Ÿæˆæ›´å¤šå˜ä½“"""
      variants = []
      # 1. å›è¯‘å¢å¼º
      back_translated = await back_translate(edge["description"])
      variants.extend(back_translated)
      # 2. å®ä½“æ›¿æ¢
      entity_replaced = await replace_entities(edge["description"])
      variants.extend(entity_replaced)
      return variants[:max_variants]
  ```

**C. é¢†åŸŸè‡ªé€‚åº”**
- **ä½ç½®**ï¼š`graphgen/models/kg_builder/light_rag_kg_builder.py`
- **å»ºè®®**ï¼šåœ¨çŸ¥è¯†æ„å»ºæ—¶ï¼Œé’ˆå¯¹ç‰¹å®šé¢†åŸŸé¢„è®­ç»ƒå®ä½“åµŒå…¥ï¼Œæå‡é¢†åŸŸå®ä½“è¯†åˆ«ç²¾åº¦
  ```python
  class DomainAdaptiveKGBuilder(LightRAGKGBuilder):
      def __init__(self, llm_client, domain_embeddings):
          super().__init__(llm_client)
          self.domain_embeddings = domain_embeddings  # é¢†åŸŸå®ä½“åµŒå…¥
      
      async def extract(self, chunk):
          # ä½¿ç”¨é¢†åŸŸåµŒå…¥å¢å¼ºå®ä½“è¯†åˆ«
          enhanced_chunk = self._enhance_with_embeddings(chunk)
          return await super().extract(enhanced_chunk)
  ```

#### 4. é€»è¾‘ä¸è¿è´¯æ€§ä¼˜åŒ–

**ç°çŠ¶åˆ†æ**ï¼š
- èšåˆQAä½¿ç”¨é‡è¿°æç¤ºï¼ˆè§`graphgen/models/generator/aggregated_generator.py`ï¼‰
- ä½†é€»è¾‘é“¾æ¡å¯èƒ½ä¸å¤Ÿæ¸…æ™°

**ä¼˜åŒ–å»ºè®®**ï¼š

**A. é€»è¾‘ç»“æ„å¼ºåŒ–**
- **ä½ç½®**ï¼š`graphgen/models/generator/aggregated_generator.py::build_prompt()`
- **å»ºè®®**ï¼šåœ¨èšåˆQAç”Ÿæˆä¸­ï¼Œæ˜¾å¼è¦æ±‚LLMè¾“å‡ºé€»è¾‘ç»“æ„å›¾ï¼ˆå¦‚å› æœé“¾ã€æ—¶é—´çº¿ï¼‰ï¼Œå†åŸºäºæ­¤ç”Ÿæˆæ–‡æœ¬
  ```python
  AGGREGATED_GENERATION_WITH_STRUCTURE = """
  Given the following knowledge graph subgraph, please:
  1. First, identify the logical structure (causal chain, timeline, hierarchy, etc.)
  2. Then, generate a coherent text based on this structure
  3. Finally, generate a question that requires understanding this structure.
  
  Knowledge Graph:
  {context}
  
  Output format:
  Structure: [logical structure]
  Answer: [coherent text]
  Question: [question]
  """
  ```

**B. å¤šè·³æ¨ç†éªŒè¯**
- **ä½ç½®**ï¼š`graphgen/models/generator/multi_hop_generator.py`
- **å»ºè®®**ï¼šå¯¹å¤šè·³QAï¼Œä½¿ç”¨è§„åˆ™å¼•æ“æˆ–ç¬¦å·é€»è¾‘éªŒè¯ç­”æ¡ˆçš„æ¨ç†è·¯å¾„æ˜¯å¦æ­£ç¡®
  ```python
  class MultiHopValidator:
      def validate_reasoning_path(self, question, answer, knowledge_graph):
          """éªŒè¯å¤šè·³æ¨ç†è·¯å¾„"""
          # æå–æ¨ç†è·¯å¾„ä¸­çš„å®ä½“å’Œå…³ç³»
          path = extract_reasoning_path(question, answer)
          # éªŒè¯è·¯å¾„åœ¨çŸ¥è¯†å›¾è°±ä¸­æ˜¯å¦å­˜åœ¨
          is_valid = verify_path_in_kg(path, knowledge_graph)
          return is_valid
  ```

**C. ä¸€è‡´æ€§æŸå¤±**
- **ä½ç½®**ï¼šè®­ç»ƒé˜¶æ®µï¼ˆä¸åœ¨å½“å‰ä»£ç åº“ä¸­ï¼‰
- **å»ºè®®**ï¼šåœ¨è®­ç»ƒé˜¶æ®µå¼•å…¥ä¸€è‡´æ€§æŸå¤±å‡½æ•°ï¼Œé¼“åŠ±æ¨¡å‹åœ¨ç±»ä¼¼ä¸Šä¸‹æ–‡ä¸­è¾“å‡ºä¸€è‡´ç­”æ¡ˆ

---

### ä¸‰ã€å®æ–½ä¼˜å…ˆçº§å»ºè®®

åŸºäº**å®æ–½éš¾åº¦**å’Œ**é¢„æœŸæ”¶ç›Š**ï¼Œå»ºè®®æŒ‰ä»¥ä¸‹ä¼˜å…ˆçº§å®æ–½ä¼˜åŒ–ï¼š

#### é«˜ä¼˜å…ˆçº§ï¼ˆä½éš¾åº¦ã€é«˜æ”¶ç›Šï¼‰
1. âœ… **æ‰¹é‡LLMè°ƒç”¨ä¼˜åŒ–** - æ˜¾è‘—å‡å°‘ç½‘ç»œå»¶è¿Ÿï¼Œå®æ–½ç®€å•
2. âœ… **å¤šæ¨¡æ¿é‡‡æ ·** - æå‡å¤šæ ·æ€§ï¼Œä»£ç æ”¹åŠ¨å°
3. âœ… **å®ä½“/å…³ç³»ç¼“å­˜** - é¿å…é‡å¤æå–ï¼ŒèŠ‚çœæˆæœ¬
4. âœ… **åŠ¨æ€å‚æ•°è°ƒæ•´** - æå‡é€‚åº”æ€§ï¼Œå®æ–½ç®€å•

#### ä¸­ä¼˜å…ˆçº§ï¼ˆä¸­ç­‰éš¾åº¦ã€ä¸­ç­‰æ”¶ç›Šï¼‰
1. âš ï¸ **å¯å‘å¼é‡‡æ ·ï¼ˆä¼˜å…ˆçº§é˜Ÿåˆ—ï¼‰** - æå‡é‡‡æ ·è´¨é‡ï¼Œéœ€è¦ç®—æ³•ä¼˜åŒ–
2. âš ï¸ **å¤šæºéªŒè¯** - æå‡å‡†ç¡®æ€§ï¼Œéœ€è¦é›†æˆå¤–éƒ¨API
3. âš ï¸ **ä¸€è‡´æ€§æ£€æŸ¥** - è¿‡æ»¤ä½è´¨é‡æ ·æœ¬ï¼Œéœ€è¦è®­ç»ƒåˆ¤åˆ«æ¨¡å‹
4. âš ï¸ **æå‰ç»ˆæ­¢** - æå‡æ•ˆç‡ï¼Œéœ€è¦è´¨é‡é˜ˆå€¼è®¾è®¡

#### ä½ä¼˜å…ˆçº§ï¼ˆé«˜éš¾åº¦ã€é•¿æœŸæ”¶ç›Šï¼‰
1. ğŸ”„ **åˆ†å¸ƒå¼å­˜å‚¨** - éœ€è¦æ¶æ„é‡æ„
2. ğŸ”„ **ä¸»åŠ¨å­¦ä¹ ** - éœ€è¦å¤æ‚çš„ä¿¡æ¯å¢ç›Šè®¡ç®—
3. ğŸ”„ **è¿­ä»£ä¿®æ­£** - éœ€è¦åé¦ˆå¾ªç¯è®¾è®¡
4. ğŸ”„ **æµæ°´çº¿å¤„ç†** - éœ€è¦å¢é‡å¤„ç†æœºåˆ¶

---

### å››ã€æ€»ç»“

GraphGenæ¡†æ¶å·²åœ¨çŸ¥è¯†å›¾è°±å¼•å¯¼çš„åˆæˆæ•°æ®ç”Ÿæˆæ–¹é¢è¡¨ç°å‡ºè‰²ï¼Œä½†åœ¨æ•ˆç‡å’Œç”Ÿæˆè´¨é‡ä¸Šä»æœ‰ä¼˜åŒ–ç©ºé—´ï¼š

- **æ•ˆç‡ä¼˜åŒ–**åº”èšç„¦äºå¹¶è¡Œå¤„ç†ã€ç¼“å­˜ç­–ç•¥å’Œç®—æ³•æ”¹è¿›ï¼Œä»¥åº”å¯¹å¤§è§„æ¨¡æ•°æ®åœºæ™¯ã€‚
- **ç”Ÿæˆè´¨é‡ä¼˜åŒ–**éœ€ä»äº‹å®å‡†ç¡®æ€§ã€å¤šæ ·æ€§ã€é•¿å°¾è¦†ç›–å’Œé€»è¾‘ä¸€è‡´æ€§å…¥æ‰‹ï¼Œç»“åˆå¤šæºéªŒè¯å’Œè¯„ä¼°åé¦ˆã€‚

**å®æ–½å»ºè®®**ï¼š
- ä»¥**è¿­ä»£æ–¹å¼**å®æ–½ä¸Šè¿°ä¼˜åŒ–ï¼Œå…ˆå¤„ç†ä½éš¾åº¦é«˜æ”¶ç›Šé¡¹ï¼ˆå¦‚æ‰¹é‡LLMè°ƒç”¨ã€å¤šæ¨¡æ¿é‡‡æ ·ï¼‰ï¼Œå†é€æ­¥æ¨è¿›å¤æ‚æ”¹è¿›ï¼ˆå¦‚ä¸»åŠ¨å­¦ä¹ ã€åˆ†å¸ƒå¼å­˜å‚¨ï¼‰ã€‚
- æŒç»­ç›‘æ§ç”Ÿæˆæ•°æ®åœ¨ä¸‹æ¸¸ä»»åŠ¡ä¸­çš„è¡¨ç°ï¼Œç¡®ä¿ä¼˜åŒ–æ–¹å‘æ­£ç¡®ã€‚
- å»ºç«‹A/Bæµ‹è¯•æœºåˆ¶ï¼Œå¯¹æ¯”ä¼˜åŒ–å‰åçš„æ•ˆæœã€‚

---

## ä¸ƒã€å‚è€ƒèµ„æ–™

- æ ¸å¿ƒä»£ç ï¼š`graphgen/graphgen.py`
- é…ç½®æ–‡ä»¶ï¼š`graphgen/configs/*.yaml`
- æç¤ºæ¨¡æ¿ï¼š`graphgen/templates/`
- è¯„ä¼°å·¥å…·ï¼š`graphgen/evaluate.py`
- CLIå·¥å…·ï¼š`graphgen_cli.py`
- Webç•Œé¢ï¼š`webui/app.py`
- APIæœåŠ¡ï¼š`backend/main.py`

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼šåŸºäºä»£ç åº“å½“å‰å®ç°  
**ç»´æŠ¤è€…**ï¼šGraphGenå¼€å‘å›¢é˜Ÿ

